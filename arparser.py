# -*- coding: utf-8 -*-
"""
Created on Tue Nov  7 12:22:12 2017

@author: rmondoncancel
"""

from collections import OrderedDict

ITEM_ACTIONS = [
]

GCD_AS_OFF_GCD = [
    'blood_drinker',
]

OFF_GCD_AS_OFF_GCD = [
    'dancing_rune_weapon',
    'arcane_torrent',
]

USABLE_SKILLS = [
    'death_strike',
    'death_and_decay',
]

INTERRUPT_SKILLS = [
    'mind_freeze',
]

# Skills for which "melee" must be specified as an argument of IsCastable
MELEE_SKILLS = [
    'mind_freeze',
]

CD_SKILLS = [
    'dancing_rune_weapon',
]

SPELL_REPLACEMENTS = {
    'And': 'and',
    'Blooddrinker': 'BloodDrinker',
    'Of': 'of',
}

UNARY_OPERATORS = {
    '-': '-',
    '!': 'not',
    'abs': 'math.abs',
    'floor': 'math.floor',
    'ceil': 'math.ceil',
}

BINARY_OPERATORS = {
    '&': 'and',
    '|': 'or',
    '+': '+',
    '-': '-',
    '*': '*',
    '%': '/',
    '=': '==',
    '!=': '~=',
    '<': '<',
    '<=': '<=',
    '>': '>',
    '>=': '>=',
    # TODO Handle the in/not_in cases
}

COMPARISON_OPERATORS = ['!=', '<=', '>=', '=', '<', '>']
ADDITION_OPERATORS = ['+', '-']
MULTIPLIACTION_OPERATORS = ['*', '%']
FUNCTION_OPERATORS = ['abs', 'floor', 'ceil']

IGNORED_ACTION_LISTS = [
    'precombat',
]

CLASS_SPECS = {
    'deathknight': ['blood', 'frost', 'unholy'],
    'demonhunter': ['havoc'],
}

RACES = [
    'blood_elf',
    'draenei',
    'dwarf',
    'gnome',
    'goblin',
    'human',
    'night_elf',
    'orc',
    'pandaren',
    'tauren',
    'troll',
    'undead',
    'worgen',
]

SPELL = 'spell'
ITEM = 'item'
BUFF = 'buff'
DEBUFF = 'debuff'
POTION = 'potion'
VARIABLE = 'variable'
RUN_ACTION_LIST = 'run_action_list'
CALL_ACTION_LIST = 'call_action_list'


def indent(string, length=2):
    """
    Indent a string by indent_size spaces at the beginning of each new line.
    """
    indent_string = '\n' + ' ' * length
    return ' ' * length + string.replace('\n', indent_string)


class LuaNamed:
    """
    An abstract class for elements whose named in lua can be parsed from its
    name in simc.
    """

    def __init__(self, simc):
        self.simc = simc

    def lua_name(self):
        """
        Return the AethysRotation name of the spell.
        """
        ar_words = [word.title() for word in self.simc.split('_')]
        ar_words = [SPELL_REPLACEMENTS[ar_word]
                    if ar_word in SPELL_REPLACEMENTS else ar_word
                    for ar_word in ar_words]
        return ''.join(ar_words)


class APL:
    """
    The main class representing an Action Priority List (or simc profile),
    extracted from its simc string.
    """

    def __init__(self):
        self.simc_lines = []
        self.player = None
        self.target = Target()
        self.profile_name = ''
        self.parsed = True
        self.apl_simc = ''
        self.show_comments = True
        self.action_lists_simc = OrderedDict()
    
    def hide_simc_comments(self):
        """
        Hide the default commented simc lines to the printed lua code.
        """
        self.show_comments = False

    def set_simc_lines(self, simc_lines):
        """
        Set the simc_lines attribute of the object to the content of the
        variable simc_lines.
        """
        self.simc_lines = [simc_line for simc_line in simc_lines
                           if not simc_line.startswith('#')]
        self.parsed = False

    def read_profile(self, file_path):
        """
        Read a .simc profile file.
        """
        with open(file_path, 'r') as profile:
            self.set_simc_lines([line.strip() for line in profile.readlines()])

    def read_string(self, multiline_simc):
        """
        Read a simc profile from a multiline string.
        """
        self.set_simc_lines(multiline_simc.split('\n'))

    def process_lua(self):
        """
        Parse the profile read from the simc_lines attribute and print the lua
        code generated by the profile.
        """
        self.parse_profile()
        return self.print_lua()

    def export_lua(self, file_path):
        """
        Parse the profile read from the simc_lines attribute and export the lua
        code generated into file_path.
        """
        self.parse_profile()
        with open(file_path, 'w') as lua_file:
            lua_file.write(self.print_lua())

    def parse_profile(self):
        """
        Parse the profile from the simc_lines attribute.
        """
        if not self.parsed:
            for simc in self.simc_lines:
                self.parse_line(simc)
            self.parsed = True

    def parse_action(self, simc):
        """
        Parse a single line from the simc_lines attribute if this line is an
        action and append it in its action_list in action_lists_simc dict.
        """
        equal_index = simc.find('+=')
        equal_len = 2
        if equal_index == -1:
            equal_index = simc.find('=')
            equal_len = 1
        if equal_index == -1:
            return
        action_call = simc[:equal_index]
        action_simc = simc[equal_index + equal_len:]
        if '.' not in action_call:
            self.apl_simc += action_simc
            return
        action_name = action_call.split('.')[1]
        if action_name not in IGNORED_ACTION_LISTS:
            if action_name in self.action_lists_simc:
                self.action_lists_simc[action_name] += action_simc
            else:
                self.action_lists_simc[action_name] = action_simc

    def main_action_list(self):
        """
        Get the ActionList object for the main action list.
        """
        return ActionList(self, self.apl_simc, 'APL')

    def action_lists(self):
        """
        Get the list of ActionList objects from action_lists_simc.
        """
        return [ActionList(self, simc, name)
                for name, simc in self.action_lists_simc.items()]

    def parse_line(self, simc):
        """
        Parse a single line in simc_lines.
        """
        if any(simc.startswith(class_) for class_ in CLASS_SPECS):
            class_, profile_name = simc.split('=')
            self.set_player(class_)
            self.set_profile_name(profile_name)
        elif simc.startswith('spec'):
            _, spec = simc.split('=')
            self.player.set_spec(spec)
        elif simc.startswith('level'):
            _, level = simc.split('=')
            self.player.set_level(level)
        elif simc.startswith('race'):
            _, race = simc.split('=')
            self.player.set_race(race)
        elif simc.startswith('actions'):
            self.parse_action(simc)

    def set_profile_name(self, simc):
        """
        Set the profile name.
        """
        self.profile_name = simc.replace('"', '')

    def set_player(self, simc):
        """
        Set a player as the main actor of the APL.
        """
        self.player = Player(simc)

    def set_target(self, simc):
        """
        Set the target of the main actor of the APL.
        """
        self.target = Target(simc)

    def print_action_lists_lua(self):
        """
        Print the lua string of the APL.
        """
        return '\n'.join(indent(action_list.print_lua())
                         for action_list in self.action_lists())

    def print_lua(self):
        """
        Print the lua string representing the action list.
        """
        function_name = self.main_action_list().name.lua_name()
        action_lists = self.print_action_lists_lua()
        main_actions = self.main_action_list().print_actions_lua()
        return (f'local function {function_name}()\n'
                f'{action_lists}\n'
                f'{main_actions}\n'
                f'end')


class Player:
    """
    Define a player as the main actor of a simulation.
    """

    def __init__(self, simc):
        self.class_ = PlayerClass(simc)
        self.spec = None
        self.level = 110
        self.race = None

    def potion(self):
        """
        Return the item of the potion used by the player.
        """
        return self.spec.potion()

    def set_spec(self, spec):
        """
        Sets the spec of the player.
        """
        self.spec = PlayerSpec(self, spec)

    def set_race(self, race):
        """
        Sets the race of the player.
        """
        self.race = PlayerRace(self, race)

    def set_level(self, level):
        """
        Sets the level of the player.
        """
        self.level = int(level)

    def print_lua(self):
        """
        Print the lua expression for the player.
        """
        return 'Player'


class Target:
    """
    Define a target of the main actor of a simulation.
    """

    def __init__(self, simc=None):
        self.simc = simc if simc is not None else 'patchwerk'

    def print_lua(self):
        """
        Print the lua expression for the target.
        """
        return 'Target'


class PlayerClass(LuaNamed):
    """
    The player class.
    """

    def __init__(self, simc):
        try:
            assert simc in CLASS_SPECS.keys()
        except AssertionError:
            ValueError(f'Invalid class {simc}.')
        super().__init__(simc)


class PlayerRace(LuaNamed):
    """
    The player race.
    """

    def __init__(self, player, simc):
        try:
            assert simc in RACES
        except AssertionError:
            ValueError(f'Invalid race {simc}.')
        self.player = player
        super().__init__(simc)


class PlayerSpec(LuaNamed):
    """
    The player spec.
    """

    def __init__(self, player, simc):
        try:
            assert simc in CLASS_SPECS[player.class_.simc]
        except AssertionError:
            ValueError(f'Invalid spec {simc} for class {player.class_.simc}.')
        self.player = player
        super().__init__(simc)

    def potion(self):
        """
        Return the potion used by a Death Knight.
        """
        if self.player.class_.simc in ['deathknight', 'demonhunter']:
            potion = 'prolonged_power'
        return potion


class ActionList:
    """
    An action list; useful when the APL defines multiple named action lists to
    handle specific decision branchings.
    """

    def __init__(self, apl, simc, name='APL'):
        self.player = apl.player
        self.target = apl.target
        self.show_comments = apl.show_comments
        self.simc = simc
        self.name = LuaNamed(name)

    def split_simc(self):
        """
        Split the simc string of an action list into unique action simc strings.
        """
        return self.simc.split('/')

    def actions(self):
        """
        Return the list of action as Action instances of the ActionList.
        """
        return [Action(self, simc) for simc in self.split_simc()]

    def print_actions_lua(self):
        """
        Print the lua string for the actions of the list (without the function
        wrapper).
        """
        return '\n'.join(indent(action.print_lua())
                         for action in self.actions())

    def print_lua(self):
        """
        Print the lua string representing the action list.
        """
        actions = self.print_actions_lua()
        function_name = self.name.lua_name()
        return (f'local function {function_name}()\n'
                f'{actions}\n'
                f'end')


class Action:
    """
    A single action in an action list. A action is of the form:
    \\actions.action_list_name+=/execution,if=condition_expression
    """

    def __init__(self, action_list, simc):
        self.action_list = action_list
        self.player = action_list.player
        self.target = action_list.target
        self.show_comments = action_list.show_comments
        self.simc = simc

    def split_simc(self):
        """
        Split the simc string of an action into its different properties
        strings.
        """
        return self.simc.split(',')

    def properties(self):
        """
        Return the named properties of the action; corresponds ton the elements
        of the form key=expression in a simc string.
        """
        props = {}
        for simc_prop in self.split_simc()[1:]:
            equal_index = simc_prop.find('=')
            simc_key = simc_prop[:equal_index]
            simc_val = simc_prop[equal_index+1:]
            props[simc_key] = simc_val
        return props

    def execution(self):
        """
        Return the execution of the action (the thing to execute if the
        condition is fulfulled).
        """
        execution_string = self.split_simc()[0]
        return Execution(self, execution_string)

    def get_expression(self, key):
        """
        Return an expression from the name of the key to parse.
        """
        if key in self.properties():
            condition_expression = self.properties()[key]
        else:
            condition_expression = ''
        return ConditionExpression(self, condition_expression)

    def condition_expression(self):
        """
        Return the condition expression of the action (the thing to test
        before doing the execution).
        """
        return self.get_expression('if')

    def value_expression(self):
        """
        Return the value expression of the action (for a variable).
        """
        return self.get_expression('value')

    def condition_tree(self):
        """
        Return the condition tree of the action (the tree form of the conditon
        expression).
        """
        return self.condition_expression().grow()

    def value_tree(self):
        """
        Return the expression tree for the value attribute, in case of a
        variable action.
        """
        return self.value_expression().grow()

    def print_lua(self):
        """
        Print the lua expression of the action.
        """
        lua_string = ''
        if self.show_comments:
            lua_string += f'-- {self.simc}\n'
        if self.execution().type_() == VARIABLE:
            fun_name = self.execution().object_().print_lua()
            var_value = self.value_tree().print_lua()
            lua_string += (f'local function {fun_name}()\n'
                           f'  return {var_value};\n'
                           f'end')
        else:
            exec_cond = self.execution().object_().print_conditions()
            cond_link = ' and ' if exec_cond != '' else ''
            if_cond = self.condition_tree().print_lua()
            exec_cast = self.execution().object_().print_cast()
            lua_string += (f'if {exec_cond}{cond_link}({if_cond}) then\n'
                           f'  {exec_cast}\n'
                           f'end')
        return lua_string


class Execution:
    """
    Represent an execution, what to do in a specific situation during the
    simulation.
    """

    def __init__(self, action, execution):
        self.action = action
        self.execution = execution

    def switch_type(self):
        """
        Return the couple type, object of the execution depending on its value.
        """
        if self.execution == POTION:
            type_, object_ = ITEM, Potion(self.action)
        elif self.execution in ITEM_ACTIONS:
            type_, object_ = ITEM, Item(self.action, self.execution)
        elif self.execution == VARIABLE:
            variable_name = self.action.properties()['name']
            type_, object_ = VARIABLE, Variable(self.action, variable_name)
        elif self.execution == RUN_ACTION_LIST:
            action_list_name = self.action.properties()['name']
            type_, object_ = (RUN_ACTION_LIST,
                              RunActionList(self.action, action_list_name))
        elif self.execution == CALL_ACTION_LIST:
            action_list_name = self.action.properties()['name']
            type_, object_ = (CALL_ACTION_LIST,
                              CallActionList(self.action, action_list_name))
        else:
            type_, object_ = SPELL, Spell(self.action, self.execution)
        return type_, object_

    def type_(self):
        """
        Get the type of the execution.
        """
        return self.switch_type()[0]

    def object_(self):
        """
        Get the object of the execution.
        """
        return self.switch_type()[1]


class BinaryOperator:
    """
    Represent a binary operator in a condition expression.
    """

    def __init__(self, symbol):
        self.symbol = symbol

    def print_lua(self):
        """
        Print the lua expression for the binary operator.
        """
        return BINARY_OPERATORS[self.symbol]


class UnaryOperator:
    """
    Represent a unary operator in a condition expression.
    """

    def __init__(self, symbol):
        self.symbol = symbol

    def print_lua(self):
        """
        Print the lua expression for the binary operator.
        """
        return UNARY_OPERATORS[self.symbol]


class ConditionExpression:
    """
    Represent a condition expression from a string extracted from a simc
    profile.
    """

    def __init__(self, action, simc, exps=None):
        expressions = exps.copy() if exps is not None else []
        self.action = action
        self.parse_parentheses(simc, expressions)

    def parse_parentheses(self, simc, expressions):
        """
        Replace first-level parentheses by {} and saves the content of
        parentheses in a list of strings.
        """
        n_parentheses = 0
        parsed_simc = ''
        for i, char in enumerate(simc):
            if char == '(':
                n_parentheses += 1
                # save index to extract substring for expressions
                if n_parentheses == 1:
                    start_index = i
            elif char == ')':
                n_parentheses -= 1
                if n_parentheses == 0:
                    end_index = i
                    expressions.append(simc[start_index + 1:end_index])
                    parsed_simc += '{}'
                if n_parentheses < 0:
                    raise ValueError('Invalid condition expression')
            elif n_parentheses == 0:
                # Only write in parsed_simc of not in a sub-expression
                parsed_simc += char
        self.simc = parsed_simc
        self.expressions = expressions

    def grow_binary_tree(self, symbol):
        """
        Grow the condition expression into a binary tree for a binary operator.
        """
        symbol_index = self.simc.find(symbol)
        left_simc = self.simc[:symbol_index]
        right_simc = self.simc[symbol_index + len(symbol):]
        n_expressions_before = left_simc.count('{}')
        left_exps = self.expressions[:n_expressions_before]
        right_exps = self.expressions[n_expressions_before:]
        return ConditionBinaryNode(
            self,
            BinaryOperator(symbol),
            ConditionExpression(self.action, left_simc, left_exps),
            ConditionExpression(self.action, right_simc, right_exps))

    def grow_unary_tree(self, symbol):
        """
        Grow the condition expression into a unary tree for a unary operator.
        """
        try:
            assert self.simc.find(symbol) == 0
        except AssertionError:
            raise ValueError((f'Invalid expression, unary operator should be '
                              f'at the beginning: {self.simc}'))
        exp = self.simc[len(symbol):]
        return ConditionUnaryNode(
            self,
            UnaryOperator(symbol),
            ConditionExpression(self.action, exp, self.expressions))

    def extract_first_operator(self, symbols, unary=False):
        """
        Extract the first operator in the symbols list. If unary, the symbol
        is a unary operator, otherwise it is a binary operator.
        """
        valid_symbols = [symbol for symbol in symbols if symbol in self.simc]
        if unary:
            symbols_indexes = [
                self.simc.find(symbol) for symbol in valid_symbols]
        else:
            # Ignores first character to force discovery of a binary operator
            # (mostly to handle the case of the - as a unary operator)
            symbols_indexes = [
                self.simc[1:].find(symbol) for symbol in valid_symbols]
        first_symbol_index = symbols_indexes.index(min(symbols_indexes))
        return valid_symbols[first_symbol_index]

    def has_symbol_in(self, symbols):
        """
        Retun true if any symbol in symbols is in the condition expression.
        """
        return any(symbol in self.simc for symbol in symbols)

    def grow(self):
        """
        Use simc precedence: https://github.com/simulationcraft/simc/wiki/ActionLists#complete-list-of-operators
        Grow the condition expression into a tree represention its condition.
        """
        if '|' in self.simc:
            tree = self.grow_binary_tree('|')
        elif '&' in self.simc:
            tree = self.grow_binary_tree('&')
        elif self.has_symbol_in(COMPARISON_OPERATORS):
            symbol = self.extract_first_operator(COMPARISON_OPERATORS)
            tree = self.grow_binary_tree(symbol)
        elif self.has_symbol_in(ADDITION_OPERATORS):
            symbol = self.extract_first_operator(ADDITION_OPERATORS)
            tree = self.grow_binary_tree(symbol)
        elif self.has_symbol_in(MULTIPLIACTION_OPERATORS):
            symbol = self.extract_first_operator(MULTIPLIACTION_OPERATORS)
            tree = self.grow_binary_tree(symbol)
        elif '!' in self.simc:
            tree = self.grow_unary_tree('!')
        elif self.has_symbol_in(FUNCTION_OPERATORS):
            symbol = self.extract_first_operator(FUNCTION_OPERATORS, unary=True)
            tree = self.grow_unary_tree(symbol)
        elif self.simc == '{}':
            try:
                assert len(self.expressions) == 1
            except AssertionError:
                raise ValueError((f'Invalid expressions stack: '
                                  f'{str(self.expressions)}'))
            tree = ConditionParenthesesNode(
                self,
                ConditionExpression(
                    self.action, self.expressions[0]))
        elif self.simc == '':
            tree = ConditionLeaf(self, 'true')
        else:
            tree = ConditionLeaf(self, self.simc)
        return tree


class ConditionNode:
    """
    Abstract class to represent a condition node in a tree representing a
    condition expression.
    """

    def __init__(self, condition_expression):
        self.action = condition_expression.action
        self.condition_expression = condition_expression

    def print_lua(self):
        """
        Print the lua code for the tree represention a condition expression.
        """
        pass


class ConditionBinaryNode(ConditionNode):
    """
    Node for a binary operator in a tree representing a condition expresion.
    """

    def __init__(self, condition_expression, operator, left_expression,
                 right_expression):
        super().__init__(condition_expression)
        self.operator = operator
        self.left_tree = left_expression.grow()
        self.right_tree = right_expression.grow()

    def print_lua(self):
        return (f'{self.left_tree.print_lua()} {self.operator.print_lua()} '
                f'{self.right_tree.print_lua()}')


class ConditionUnaryNode(ConditionNode):
    """
    Node for a unary operator in a tree representing a condition expresion.
    """

    def __init__(self, condition_expression, operator, sub_expression):
        super().__init__(condition_expression)
        self.operator = operator
        self.sub_tree = sub_expression.grow()

    def print_lua(self):
        return f'{self.operator.print_lua()} {self.sub_tree.print_lua()}'


class ConditionParenthesesNode(ConditionNode):
    """
    Node for parentheses in a tree representing a condition expresion.
    """

    def __init__(self, condition_expression, sub_expression):
        super().__init__(condition_expression)
        self.sub_tree = sub_expression.grow()

    def print_lua(self):
        return f'({self.sub_tree.print_lua()})'


class ConditionLeaf(ConditionNode):
    """
    Node for a leaf containing a singleton condition in a tree representing a
    condition expresion.
    """

    def __init__(self, condition_expression, condition):
        super().__init__(condition_expression)
        self.condition = Condition(condition_expression, condition)

    def print_lua(self):
        return f'{self.condition.expression().print_lua()}'


class LuaCastable:
    """
    The class for castable elements: items and spells.
    """

    def condition_method(self):
        """
        Return the method to use in the default condition, which usually tests
        whether the action is doable.
        """
        pass

    def condition_args(self):
        """
        Return the arguments of the default condition, which usually tests
        whether the action is doable.
        """
        return []

    def condition(self):
        """
        Return the LuaExpression of the default condition.
        """
        return LuaExpression(self, self.condition_method(),
                             self.condition_args())

    def additional_conditions(self):
        """
        Additional conditions to test for the specific action; [] by default if
        none.
        """
        return []

    def conditions(self):
        """
        List of conditions to check before executing the action.
        """
        return [self.condition()] + self.additional_conditions()

    def print_conditions(self):
        """
        Print the lua code for the condition of the execution.
        """
        return ' and '.join(condition.print_lua()
                            for condition in self.conditions())

    def cast_method(self):
        """
        The method to call when executing the action.
        """
        return Method('Cast')

    def cast_args(self):
        """
        The arguments of the method used to cast the action.
        """
        return [self]

    def cast(self):
        """
        Return the LuaExpression to cast the action.
        """
        return LuaExpression(Literal('AR'),
                             self.cast_method(), self.cast_args())

    def cast_template(self):
        """
        The template of the code to execute the action; {} will be replaced by
        the result of self.cast().print_lua().
        """
        return 'if {} then return ""; end'

    def print_cast(self):
        """
        Print the lua code of what to do when casting the action.
        """
        return self.cast_template().format(self.cast().print_lua())


class Item(LuaNamed, LuaCastable):
    """
    The Item class, used to represent an item.
    """

    def __init__(self, action, simc):
        super().__init__(simc)
        self.action = action

    def condition_method(self):
        return Method('IsReady')

    def cast_method(self):
        return Method('CastSuggested')

    def print_lua(self):
        """
        Print the lua representation of the item.
        """
        return f'I.{self.lua_name()}'


class Potion(Item):
    """
    The Potion class, to handle the specific case of a potion.
    """

    def __init__(self, action):
        super().__init__(action, action.player.potion())

    def additional_conditions(self):
        return [Literal('Settings.Commons.UsePotions')]


class RunActionList(LuaNamed, LuaCastable):
    """
    The class to handle a run_action_string action; calls a function containing
    the code for the speficic ActionList called.
    """

    def __init__(self, action, simc):
        super().__init__(simc)
        self.action = action

    def conditions(self):
        return []

    def cast(self):
        return Literal(self.lua_name() + '()')

    def cast_template(self):
        return 'return {};'


class CallActionList(LuaNamed, LuaCastable):
    """
    The class to handle a call_action_string action; calls a function containing
    the code for the speficic ActionList called.
    """

    def __init__(self, action, simc):
        super().__init__(simc)
        self.action = action

    def conditions(self):
        return []

    def cast(self):
        return Literal(self.lua_name() + '()')

    def cast_template(self):
        return ('local ShouldReturn = {}; '
                'if ShouldReturn then return ShouldReturn; end')


class Variable(LuaNamed):
    """
    The class to handle a variable action; this creates a new variable as a
    local function to compute a value used afterwards.
    """

    def __init__(self, action, simc):
        super().__init__(simc)
        self.action = action

    def print_lua(self):
        """
        Print the lua name of a variable.
        """
        return f'{self.lua_name()}'


class Spell(LuaNamed, LuaCastable):
    """
    Represents a spell; it can be either a spell, a buff or a debuff.
    """

    def __init__(self, action, simc, type_=SPELL):
        super().__init__(simc)
        self.action = action
        self.type_ = type_

    def condition_method(self):
        if self.simc in USABLE_SKILLS:
            return Method('IsUsable')
        return Method('IsCastable')

    def condition_args(self):
        if self.simc in MELEE_SKILLS:
            return [Literal('"melee"')]
        return []

    def additional_conditions(self):
        if self.simc in INTERRUPT_SKILLS:
            return [Literal('Settings.General.InterruptEnabled'),
                    LuaExpression(self.action.target,
                                  Method('IsInterruptible'), [])]
        return []

    def cast_method(self):
        if self.simc in INTERRUPT_SKILLS:
            return Method('CastAnnotated')
        return Method('Cast')

    def cast_args(self):
        args = [self]
        if self.simc in GCD_AS_OFF_GCD:
            args.append(Literal('Settings.'
                                f'{self.action.player.spec.lua_name()}.'
                                'GCDasOffGCD.'
                                f'{self.lua_name()}'))
        if self.simc in OFF_GCD_AS_OFF_GCD:
            args.append(Literal('Settings.'
                                f'{self.action.player.spec.lua_name()}.'
                                'OffGCDasOffGCD.'
                                f'{self.lua_name()}'))
        if self.simc in INTERRUPT_SKILLS:
            args.append(Literal('false'))
            args.append(Literal('"Interrupt"'))
        return args

    def print_lua(self):
        """
        Print the lua expression for the spell.
        """
        if self.type_ == BUFF:
            return f'S.{self.lua_name()}Buff'
        elif self.type_ == DEBUFF:
            return f'S.{self.lua_name()}Debuff'
        return f'S.{self.lua_name()}'


class Condition:
    """
    Represent a singleton condition (i.e. without any operator).
    """

    def __init__(self, condition_expression, simc):
        self.condition_expression = condition_expression
        self.parent_action = condition_expression.action
        self.simc = simc

    def expression(self):
        """
        Return the expression of the condition.
        """
        if (self.condition_list()[0] in self.actions_to_self()
                and len(self.condition_list()) == 1):
            return self.action(to_self=True)
        try:
            return getattr(self, self.condition_list()[0])()
        except AttributeError:
            return Literal(self.simc)

    def actions_to_self(self):
        """
        The list of actions that can be applied to self (i.e. the execution of
        the action) for shortcut.
        """
        return [method for method in dir(ActionCondition)
                if callable(getattr(ActionCondition, method))
                and not method.startswith('__') and not method == 'print_lua']

    def condition_list(self):
        """
        Return the splitted structure of the condition.
        """
        return self.simc.split('.')

    def action(self, to_self=False):
        """
        Return the condition when the prefix is action.
        """
        return ActionCondition(self, to_self)

    def cooldown(self):
        """
        Return the condition when the prefix is cooldown.
        """
        return Cooldown(self)

    def buff(self):
        """
        Return the condition when the prefix is buff.
        """
        return Buff(self)

    def gcd(self):
        """
        Return the condition when the prefix is gcd.
        """
        return GCD(self)

    def runic_power(self):
        """
        Return the condition when the prefix is runic_power.
        """
        return RunicPower(self)

    def talent(self):
        """
        Return the condition when the prefix is talent.
        """
        return Talent(self)

    def charges_fractional(self):
        """
        Return the condition when the prefix is charges_fractional.
        """
        return LuaExpression(Spell(self.parent_action, 'blood_boil'),
                             Method('ChargesFractional'), [])

    def rune(self):
        """
        Return the condition when the prefix is rune.
        """
        return Rune(self)

    def target(self):
        """
        Return the condition when the prefix is target.
        """
        return TargetCondition(self)

    def fury(self):
        """
        Return the condition when the prefix is fury.
        """
        return Fury(self)

    def variable(self):
        """
        Return the condition when the prefix is variable.
        """
        lua_method = LuaNamed(self.condition_list()[1]).lua_name()
        return LuaExpression(None, Method(lua_method), [])


class LuaExpression:
    """
    Abstract class representing a generic lua expression in the form:
    object:method(args)
    """

    def __init__(self, object_, method, args):
        self.object_ = object_
        self.method = method
        self.args = args

    def print_lua(self):
        """
        Print the lua code for the expression
        """
        object_caller = f'{self.object_.print_lua()}:' if self.object_ else ''
        return (f'{object_caller}{self.method.print_lua()}('
                f'{", ".join(arg.print_lua() for arg in self.args)})')


class ActionCondition(LuaExpression):
    """
    Represent the expression for a action. condition.
    """

    def __init__(self, condition, to_self=False):
        self.condition = condition
        self.to_self = to_self
        if to_self:
            call = condition.condition_list()[0]
        else:
            call = condition.condition_list()[2]
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def action_object(self):
        """
        The object of the action, depending on whether the action is applied to
        self (i.e. the execution) or not.
        """
        if self.to_self:
            return self.condition.parent_action.execution().object_()
        else:
            return Spell(self.condition.parent_action,
                         self.condition.condition_list()[1])

    def recharge_time(self):
        """
        Return the arguments for the expression action.spell.recharge_time.
        """
        object_ = self.action_object()
        method = Method('RechargeP')
        args = []
        return object_, method, args

    def cast_time(self):
        """
        Return the arguments for the expression action.spell.cast_time.
        """
        object_ = self.action_object()
        method = Method('CastTime')
        args = []
        return object_, method, args

    def charges(self):
        """
        Return the arguments for the expression action.spell.charges.
        """
        object_ = self.action_object()
        method = Method('ChargesP')
        args = []
        return object_, method, args


class GCD(LuaExpression):
    """
    Represent the expression for a gcd. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        if len(condition.condition_list()) > 1:
            call = condition.condition_list()[1]
        else:
            call = 'value'
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def remains(self):
        """
        Return the arguments for the expression gcd.deficit.
        """
        object_ = self.condition.parent_action.player
        method = Method('GCDRemains')
        args = []
        return object_, method, args

    def value(self):
        """
        Return the arguments for the expression gcd.
        """
        object_ = self.condition.parent_action.player
        method = Method('GCD')
        args = []
        return object_, method, args


class Rune(LuaExpression):
    """
    Represent the expression for a rune. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        call = condition.condition_list()[1]
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def time_to_3(self):
        """
        Return the arguments for the expression rune.time_to_3.
        """
        object_ = self.condition.parent_action.player
        method = Method('RuneTimeToX')
        args = [Literal('3')]
        return object_, method, args


class Talent(LuaExpression):
    """
    Represent the expression for a talent. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        call = condition.condition_list()[2]
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def enabled(self):
        """
        Return the arguments for the expression talent.spell.enabled.
        """
        object_ = Spell(self.condition.parent_action,
                        self.condition.condition_list()[1])
        method = Method('IsAvailable')
        args = []
        return object_, method, args


class RunicPower(LuaExpression):
    """
    Represent the expression for a runic_power. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        if len(condition.condition_list()) > 1:
            call = condition.condition_list()[1]
        else:
            call = 'value'
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def deficit(self):
        """
        Return the arguments for the expression runic_power.deficit.
        """
        object_ = self.condition.parent_action.player
        method = Method('RunicPowerDeficit')
        args = []
        return object_, method, args

    def value(self):
        """
        Return the arguments for the expression runic_power.
        """
        object_ = self.condition.parent_action.player
        method = Method('RunicPower')
        args = []
        return object_, method, args


class Fury(LuaExpression):
    """
    Represent the expression for a fury. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        if len(condition.condition_list()) > 1:
            call = condition.condition_list()[1]
        else:
            call = 'value'
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def deficit(self):
        """
        Return the arguments for the expression fury.deficit.
        """
        object_ = self.condition.parent_action.player
        method = Method('FuryDeficit')
        args = []
        return object_, method, args

    def value(self):
        """
        Return the arguments for the expression fury.
        """
        object_ = self.condition.parent_action.player
        method = Method('Fury')
        args = []
        return object_, method, args


class Debuff(LuaExpression):
    """
    Represent the expression for a debuff. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        call = condition.condition_list()[2]
        call = 'ready' if call == 'up' else call
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def ready(self):
        """
        Return the arguments for the expression debuff.spell.up.
        """
        object_ = self.condition.parent_action.player
        method = Method('Debuff')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], DEBUFF)]
        return object_, method, args

    def down(self):
        """
        Return the arguments for the expression debuff.spell.down.
        """
        object_ = self.condition.parent_action.player
        method = Method('DebuffDown')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], DEBUFF)]
        return object_, method, args

    def stack(self):
        """
        Return the arguments for the expression debuff.spell.stack.
        """
        object_ = self.condition.parent_action.player
        method = Method('DebuffStack')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], DEBUFF)]
        return object_, method, args

    def remains(self):
        """
        Return the arguments for the expression debuff.spell.remains.
        """
        object_ = self.condition.parent_action.player
        method = Method('DebuffRemains')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], DEBUFF)]
        return object_, method, args


class Buff(LuaExpression):
    """
    Represent the expression for a buff. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        call = condition.condition_list()[2]
        call = 'ready' if call == 'up' else call
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def ready(self):
        """
        Return the arguments for the expression buff.spell.up.
        """
        object_ = self.condition.parent_action.player
        method = Method('Buff')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], BUFF)]
        return object_, method, args

    def down(self):
        """
        Return the arguments for the expression buff.spell.down.
        """
        object_ = self.condition.parent_action.player
        method = Method('BuffDown')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], BUFF)]
        return object_, method, args

    def stack(self):
        """
        Return the arguments for the expression buff.spell.stack.
        """
        object_ = self.condition.parent_action.player
        method = Method('BuffStack')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], BUFF)]
        return object_, method, args

    def remains(self):
        """
        Return the arguments for the expression buff.spell.remains.
        """
        object_ = self.condition.parent_action.player
        method = Method('BuffRemains')
        args = [Spell(self.condition.parent_action,
                      self.condition.condition_list()[1], BUFF)]
        return object_, method, args


class Cooldown(LuaExpression):
    """
    Represent the expression for a cooldown. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        if len(condition.condition_list()) > 2:
            call = condition.condition_list()[2]
        else:
            call = 'remains'
        call = 'ready' if call == 'up' else call
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def ready(self):
        """
        Return the arguments for the expression cooldown.spell.ready.
        """
        object_ = Spell(self.condition.parent_action,
                        self.condition.condition_list()[1])
        method = Method('IsReady')
        args = []
        return object_, method, args

    def remains(self):
        """
        Return the arguments for the expression cooldown.spell.remains.
        """
        if len(self.condition.condition_list()) > 1:
            object_ = Spell(self.condition.parent_action,
                            self.condition.condition_list()[1])
        else:
            object_ = self.condition.parent_action.execution().object_()
        method = Method('CooldownRemainsP')
        args = []
        return object_, method, args


class TargetCondition(LuaExpression):
    """
    Represent the expression for a target. condition.
    """

    def __init__(self, condition):
        self.condition = condition
        call = condition.condition_list()[1]
        object_, method, args = getattr(self, call)()
        super().__init__(object_, method, args)

    def time_to_die(self):
        """
        Return the arguments for the expression cooldown.spell.ready.
        """
        object_ = self.condition.parent_action.target
        method = Method('TimeToDie')
        args = []
        return object_, method, args


class Method:
    """
    Represent a lua method.
    """

    def __init__(self, name):
        self.name = name

    def print_lua(self):
        """
        Print the method.
        """
        return self.name


class Literal:
    """
    Represent a literal expression (a value) as a string.
    """

    def __init__(self, value):
        self.value = value

    def print_lua(self):
        """
        Print the literal value.
        """
        return self.value


def main(simc_profile, lua_file):
    """
    Function to process if ARParser is used as a script.
    """
    apl = APL()
    apl.read_profile(simc_profile)
    apl.export_lua(lua_file)


if __name__ == '__main__':
    main('test_profile2.simc', 'test_profile2.lua')
